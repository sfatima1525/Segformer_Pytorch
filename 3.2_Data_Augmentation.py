# -*- coding: utf-8 -*-
"""3_Data Augmentation.ipny

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10_EM5OzNEYHxVlrx0GeLXbfsUgwFsFuf
"""

import os
import numpy as np
from PIL import Image, ImageOps
from collections import defaultdict
from tqdm import tqdm
import random

class_names = {
    0: "EPI",
    1: "GLD",
    2: "INF",
    3: "RET",
    4: "FOL",
    5: "PAP",
    6: "HYP",
    7: "KER",
    8: "BKG",
    9: "BCC",
    10: "SCC",
    11: "IEC"
}

def is_background_only(mask, background_color=(0, 0, 0)):
    # Check if the mask contains only the background color
    return np.all(mask == background_color)

def remove_background_images(patch_dir, save_dir):
    os.makedirs(save_dir, exist_ok=True)

    for file in tqdm(os.listdir(patch_dir), desc="Removing background-only images"):
        if not file.endswith('.png'):
            continue

        label_path = os.path.join(patch_dir, file)
        label = Image.open(label_path).convert("RGB")
        mask = np.array(label)

        if not is_background_only(mask):
            # Save non-background images to the new directory
            label.save(os.path.join(save_dir, file))

def calculate_class_distribution(patch_dir):
    class_counts = defaultdict(int)
    total_patches = 0

    for file in tqdm(os.listdir(patch_dir), desc="Calculating class distribution"):
        if not file.endswith('.png'):
            continue

        label_path = os.path.join(patch_dir, file)
        label = Image.open(label_path).convert("RGB")
        mask = np.array(label)

        unique, counts = np.unique(mask, return_counts=True)
        for cls, count in zip(unique, counts):
            class_counts[cls] += count

        total_patches += 1

    total_pixels = sum(class_counts.values())
    class_distribution = {k: (v / total_pixels) * 100 for k, v in class_counts.items()}

    return class_counts, class_distribution, total_patches

def identify_classes_to_augment(class_counts, target_percentage=50):
    total_pixels = sum(class_counts.values())
    class_targets = {cls: (target_percentage / 100) * total_pixels for cls in class_counts.keys()}

    classes_to_augment = {cls: max(0, class_targets[cls] - class_counts.get(cls, 0)) for cls in class_targets}

    return classes_to_augment

def augment_class_data(patch_dir, save_dir, classes_to_augment, augment_factor=10):
    os.makedirs(save_dir, exist_ok=True)

    for file in tqdm(os.listdir(patch_dir), desc="Augmenting underrepresented classes"):
        if not file.endswith('.png'):
            continue

        label_path = os.path.join(patch_dir, file)
        label = Image.open(label_path).convert("RGB")
        mask = np.array(label)

        for cls, needed_pixels in classes_to_augment.items():
            if needed_pixels <= 0:
                continue

            cls_pixels = np.sum(mask == cls)
            if cls_pixels < needed_pixels:
                # Augment by flipping and rotating
                for idx in range(augment_factor):
                    augmented_label = augment_image(label, file, idx)
                    augmented_label.save(os.path.join(save_dir, f"{file[:-4]}_aug_{idx}.png"))

def augment_image(image, original_filename, idx):
    augmented_images = []
    augmented_images.append(image)  # Original image

    # Rotate
    for angle in [90, 180, 270]:
        augmented_images.append(image.rotate(angle))

    # Flip
    #augmented_images.append(ImageOps.mirror(image))
    #augmented_images.append(ImageOps.flip(image))

    return random.choice(augmented_images)  # Randomly select an augmented image

def balance_dataset(patch_dir, save_dir, target_percentage=50, augment_factor=10):
    temp_dir = '/tmp/filtered_images'  # Temporary directory to hold filtered images
    remove_background_images(patch_dir, temp_dir)

    class_counts, _, total_patches = calculate_class_distribution(temp_dir)
    classes_to_augment = identify_classes_to_augment(class_counts, target_percentage)

    augment_class_data(temp_dir, save_dir, classes_to_augment, augment_factor)

    print("Dataset balancing complete.")

patch_dir = '/home/sfatima7/sanas_research/project_1/DATASET_10X/10x/Data_Augmentation/Train_X/bkg_remove/Image/'
save_dir = '/home/sfatima7/sanas_research/project_1/DATASET_10X/10x/Data_Augmentation/Train_X/New_Train_Patch_Images/'

balance_dataset(patch_dir, save_dir)